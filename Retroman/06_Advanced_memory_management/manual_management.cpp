#include <iostream>
#include <cstdint>
#include <iomanip>
 
// Pretty print a 2-digits hexadecimal value
void printHexVal(uint16_t val) {
   std::cout << std::hex << std::setw(2) << std::setfill('0') << val;
}
 
// Print a memory slice as raw bytes
void printRawMem(uint8_t* p, uint16_t linebytes, uint16_t lines) {
   for(uint16_t l=0; l < lines; ++l) {
      std::cout << reinterpret_cast<uint16_t*>(p) << " ";
      for(uint16_t u=0; u < linebytes; ++u) {
         printHexVal(*p);
         ++p;
         std::cout << " ";
      }
      std::cout << "\n";
   }
}
 
// The name Arena is what is usually used when doing placement new and our own memory management
// This class is missing the deallocate. 

// When we delete an object there's an empty space in our memory.
// When we do a new allocation, we would probably traverse our memory looking 
// for an empty space for our new allocation. 
// We could also use down time in our program to reestructure it so that the current elements in our container
// can be reorganized linearly. 
class Arena
{
public:
    Arena(std::size_t size)
    {
        // they will initially be the same
        m_nextplace = m_memory = new uint8_t[size];
    }

    ~Arena()
    {
        delete[] m_memory;
    }

    void* allocate(std::size_t size)
    {
        uint8_t* p = m_nextplace; // store current "unused" space
        m_nextplace += size; // move m_nextplace to next byte of unused memory
        return p;

    }

    void deallocate(void* p)
    {

    }
private:
    uint8_t *m_memory, *m_nextplace;

};

// we define new placement and delete for our class Arena
void *operator new(std::size_t size, Arena& A)
{
    return A.allocate(size);
}

void operator delete(void *p, Arena& A)
{
    return A.deallocate(p);
}

// A simple CGameObject Class
class CGameObject {
public:
   CGameObject(uint16_t x, uint16_t y)
      : m_x(x), m_y(y), m_id(ms_id++) {
      std::cout << "Creating CGameObject " << m_id
                << " (" << m_x << ", " << m_y << ") "
                << " at ( " << this << ", " << sizeof(*this) << ")\n";
   }
   ~CGameObject() {
      std::cout << "Destroying CGameObject " << m_id << "\n";
   }
 
private:
   static uint32_t ms_id;
   uint32_t m_id;
   uint16_t m_x, m_y;
};
 
uint32_t CGameObject::ms_id = 1;
 
int main() {
   CGameObject *g1, *g2;
   uint8_t* p;

   std::cout << "Start\n";
/* 
   // allocating 128 bytes
   uint8_t* x = new uint8_t[128];
    
    // we can convert the pointer to uint8_t gameobject and point to the corresponding position 
    // but we have no way to call the constructor
    // g1 = reinterpret_cast<CGameObject*>(x);
    // g2 = reinterpret_cast<CGameObject*>(x) + 1;
   
   // We can have g1 point to x and call the constructor using placement new. 
   g1 = new (x) CGameObject(1, 2);
   g2 = new (x + sizeof(CGameObject)) CGameObject(3, 7);

   // we're going to create a class to make a more general way of doing this. 
*/

    // Now we use our Arena class
    Arena myMem(128);

    g1 = new (myMem) CGameObject(1, 2);
    g2 = new (myMem) CGameObject(3, 7);

   // Print memory
   p  = reinterpret_cast<uint8_t*>(g1) - 16;
   printRawMem(p, 16, 4);
   std::cout << "--------------\n";
   g2->~CGameObject();      // destroy the object
   myMem.deallocate(g2);    // free memory
   
   printRawMem(p, 16, 4);  
   std::cout << "--------------\n";
   g1->~CGameObject();
   myMem.deallocate(g1);
 
   printRawMem(p, 16, 4);

//    We don't have to do this since our Arena class does it for us when it leaves the scope since it's in the stack.
//    delete[] x;
   
   return 0;
}

// With manual memory management, we save memory since we don't have 
// the extra memory generated by each time we do new.